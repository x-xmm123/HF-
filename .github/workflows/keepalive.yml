name: HG Stay active

on:
  workflow_dispatch:
  schedule:
    - cron: '0 * * * *' # ÊØèÂ∞èÊó∂Êï¥ÁÇπËøêË°åÔºàÁ§∫‰æãÔºâÔºåÊåâÈúÄ‰øÆÊîπÊàñÁßªÈô§

jobs:
  ping-spaces:
    runs-on: ubuntu-latest
    env:
      MAX_ATTEMPTS: 3
      BASE_SLEEP: 5
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run HF Spaces ping script
        id: ping
        run: |
          set -uo pipefail
          
          HF_SPACES_RAW="${{ secrets.HF_SPACES_RAW }}"
          HF_TOKENS_RAW="${{ secrets.HF_TOKENS_RAW }}"

          MAX_ATTEMPTS="${MAX_ATTEMPTS:-3}"
          BASE_SLEEP="${BASE_SLEEP:-5}"

          if [ -z "${HF_SPACES_RAW:-}" ]; then
            echo "::error::HF_SPACES_RAW secret is not set or empty"
            echo "any_failed=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          if [ -z "${HF_TOKENS_RAW:-}" ]; then
            echo "::error::HF_TOKENS_RAW secret is not set or empty"
            echo "any_failed=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # helper: split string into bash array
          split_to_array() {
            raw="$1"
            mapfile -t arr < <(printf "%s" "$raw" | tr ',' '\n' | sed 's/\r//g' | sed '/^[[:space:]]*$/d')
            for i in "${!arr[@]}"; do
              arr[$i]="$(echo "${arr[$i]}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
            done
            printf '%s\0' "${arr[@]}"
          }

          IFS= read -r -d '' -a SPACES < <(split_to_array "$HF_SPACES_RAW") || true
          IFS= read -r -d '' -a TOKENS < <(split_to_array "$HF_TOKENS_RAW") || true

          if [ ${#SPACES[@]} -ne ${#TOKENS[@]} ]; then
            echo "::error::HF_SPACES and HF_TOKENS count mismatch (must be same number and order)"
            echo "HF_SPACES count: ${#SPACES[@]}, HF_TOKENS count: ${#TOKENS[@]}"
            echo "any_failed=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Found ${#SPACES[@]} spaces to process."
          any_failed=0

          for idx in "${!SPACES[@]}"; do
            space="${SPACES[$idx]}"
            token="${TOKENS[$idx]}"

            echo "=============================="
            echo "Processing [$((idx+1))/${#SPACES[@]}] space: $space"

            safe_name="$(echo "$space" | sed 's/[^a-zA-Z0-9._-]/_/g')"
            ping_body_file="ping_response_${safe_name}.txt"
            ping_header_file="ping_headers_${safe_name}.headers"

            # üîπ ËÆøÈóÆÈ°πÁõÆÈ¶ñÈ°µ
            ping_url="https://${space}-${token}.hf.space/"
            echo "Ping URL: $ping_url"

            success=0
            attempt=1
            while [ $attempt -le ${MAX_ATTEMPTS} ]; do
              echo "Ping attempt $attempt / ${MAX_ATTEMPTS} ..."
              code=$(curl -sS -L -D "$ping_header_file" -o "$ping_body_file" -w "%{http_code}" \
                     --max-time 30 \
                     "$ping_url" || echo "000")

              echo " -> HTTP $code, ping body bytes: $(wc -c < "$ping_body_file" || echo 0)"
              echo "---- ping headers (first 20 lines) ----"
              head -n 20 "$ping_header_file" || true
              echo "---- ping body (first 200 chars) ----"
              head -c 200 "$ping_body_file" | sed -n '1,10p' || true
              echo "-------------------------------------------"

              if echo "$code" | grep -E -q "^(2|3)"; then
                if grep -qi "gradio-app" "$ping_body_file" || grep -qi "gradio.js" "$ping_body_file"; then
                  echo "‚úÖ Space $space: ‰øùÊ¥ªÊàêÂäüÔºåÈ°πÁõÆÈ¶ñÈ°µÂú®ËøêË°å (HTTP $code)"
                  success=1
                  break
                elif grep -qi "Space is currently sleeping" "$ping_body_file"; then
                  echo "::error::Space $space: Ê£ÄÊµãÂà∞‰ºëÁú†ÊèêÁ§∫È°µÈù¢ (HTTP $code)"
                  success=0
                else
                  echo "::warning::Space $space: ËøîÂõûÊú™Áü•È°µÈù¢ (HTTP $code)ÔºåÊó†Ê≥ïÁ°ÆËÆ§ÊòØÂê¶ËøêË°å"
                  success=0
                fi
              fi

              if [ $attempt -lt ${MAX_ATTEMPTS} ]; then
                sleep_seconds=$(( BASE_SLEEP * attempt ))
                echo "Sleeping $sleep_seconds seconds before next attempt..."
                sleep $sleep_seconds
              fi
              attempt=$((attempt + 1))
            done

            if [ $success -eq 1 ]; then
              rm -f "$ping_body_file" "$ping_header_file" || true
            else
              echo "::error::Space $space: ‰øùÊ¥ªÂ§±Ë¥• ‚Äî ÊâÄÊúâÂ∞ùËØïÂùáÂ§±Ë¥•"
              any_failed=1
              # ‰øùÁïôÂìçÂ∫îÊñá‰ª∂‰æõ artifact ‰∏ä‰º†
            fi

            echo "=============================="
          done

          if [ $any_failed -eq 1 ]; then
            echo "any_failed=true" >> "$GITHUB_OUTPUT"
          else
            echo "any_failed=false" >> "$GITHUB_OUTPUT"
          fi
          exit 0
        env:
          HF_SPACES_RAW: ${{ secrets.HF_SPACES_RAW }}
          HF_TOKENS_RAW: ${{ secrets.HF_TOKENS_RAW }}

      - name: Upload failure artifacts
        if: steps.ping.outputs.any_failed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: hf-space-failed-responses
          path: |
            ping_response_*.txt
            ping_headers_*.headers
          retention-days: 3

      - name: Fail job if any ping failed
        if: steps.ping.outputs.any_failed == 'true'
        run: |
          echo "One or more Spaces ‰øùÊ¥ªÂ§±Ë¥•. Failing the job as requested."
          exit 1
